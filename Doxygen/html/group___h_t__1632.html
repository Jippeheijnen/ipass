<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iPass: HT_1632</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iPass
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___h_t__1632.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">HT_1632</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e49c60cb79e44ba9f67d33c1986b5e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga4e49c60cb79e44ba9f67d33c1986b5e6">matrix::HT_1632::sendCommand</a> (uint16_t cmd)</td></tr>
<tr class="memdesc:ga4e49c60cb79e44ba9f67d33c1986b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">cendCommand function. This function is quite simple, and it is only used internally in the background. It does the following:  <a href="#ga4e49c60cb79e44ba9f67d33c1986b5e6">More...</a><br /></td></tr>
<tr class="separator:ga4e49c60cb79e44ba9f67d33c1986b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d327b762c8245ddc6f88ba26c46e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#gac3d327b762c8245ddc6f88ba26c46e82">matrix::HT_1632::writeRam</a> (uint8_t addr, uint8_t data)</td></tr>
<tr class="memdesc:gac3d327b762c8245ddc6f88ba26c46e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteRam function. The writeRam function writes data to the ram register directly. How it works: The complete transaction has a total of 14 bits, they are arranged as following:  <a href="#gac3d327b762c8245ddc6f88ba26c46e82">More...</a><br /></td></tr>
<tr class="separator:gac3d327b762c8245ddc6f88ba26c46e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7125530a962e17d9a533453e10d19e15"><td class="memItemLeft" align="right" valign="top"><a id="ga7125530a962e17d9a533453e10d19e15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga7125530a962e17d9a533453e10d19e15">matrix::HT_1632::dumpMem</a> ()</td></tr>
<tr class="memdesc:ga7125530a962e17d9a533453e10d19e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">DumpMem function. This function loops over the internal memory buffer and clears it. If the 'debug' define is set to true in the header file, the function shows the previous bitvalues stored in the buffer before clearing it. If debug is left as is, no output will be generated and the memory will be cleared without confirmation. <br /></td></tr>
<tr class="separator:ga7125530a962e17d9a533453e10d19e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2a79fd8a1be6e44b847d8548962400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga6f2a79fd8a1be6e44b847d8548962400">matrix::HT_1632::HT_1632</a> (<a class="el" href="classspi_1_1bus.html">spi::bus</a> spi_bus, uint16_t type)</td></tr>
<tr class="memdesc:ga6f2a79fd8a1be6e44b847d8548962400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor. This is the constructor of my library,.  <a href="#ga6f2a79fd8a1be6e44b847d8548962400">More...</a><br /></td></tr>
<tr class="separator:ga6f2a79fd8a1be6e44b847d8548962400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e8cf0207f395b420124b73555abea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga41e8cf0207f395b420124b73555abea1">matrix::HT_1632::setPixel</a> (uint16_t x, uint16_t y)</td></tr>
<tr class="memdesc:ga41e8cf0207f395b420124b73555abea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SetPixel function. The setPixel function is quite self-explanatory, it sets pixels at location x, y.  <a href="#ga41e8cf0207f395b420124b73555abea1">More...</a><br /></td></tr>
<tr class="separator:ga41e8cf0207f395b420124b73555abea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51370333005f486fb0d2877fe459e596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga51370333005f486fb0d2877fe459e596">matrix::HT_1632::clearPixel</a> (uint16_t x, uint16_t y)</td></tr>
<tr class="memdesc:ga51370333005f486fb0d2877fe459e596"><td class="mdescLeft">&#160;</td><td class="mdescRight">ClearPixel function. The reverse of the setPixel function.  <a href="#ga51370333005f486fb0d2877fe459e596">More...</a><br /></td></tr>
<tr class="separator:ga51370333005f486fb0d2877fe459e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c948d2a7639d54c6cc2a0d6aee0d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#gac1c948d2a7639d54c6cc2a0d6aee0d2f">matrix::HT_1632::blink</a> (uint16_t seconds)</td></tr>
<tr class="memdesc:gac1c948d2a7639d54c6cc2a0d6aee0d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blink function. This function lets you blink the whole matrix for x amount of seconds.  <a href="#gac1c948d2a7639d54c6cc2a0d6aee0d2f">More...</a><br /></td></tr>
<tr class="separator:gac1c948d2a7639d54c6cc2a0d6aee0d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed82c4f2f682bcd439aa8a745f01f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga5ed82c4f2f682bcd439aa8a745f01f0f">matrix::HT_1632::writeScreen</a> ()</td></tr>
<tr class="memdesc:ga5ed82c4f2f682bcd439aa8a745f01f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteScreen function. WriteScreen is similar to hwlib::window::flush(), what it does is send the data stored in the memory buffer to the HT1632 chip. What's so special about this function is the following: It uses 'successive writing' which is a particular way of writing data over spi. Successive writing enables you to send data far more quickly than writing per register. This is because with successive writing only the first register address is sent, after that comes only data. I first used writeRam to write to each register individually but this was much slower because I had to sent each address too. With successive writing that's not required.  <a href="#ga5ed82c4f2f682bcd439aa8a745f01f0f">More...</a><br /></td></tr>
<tr class="separator:ga5ed82c4f2f682bcd439aa8a745f01f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942af7e6d95cc5d44778cb5ba2f56b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#ga942af7e6d95cc5d44778cb5ba2f56b36">matrix::HT_1632::setBrightness</a> (uint8_t b)</td></tr>
<tr class="memdesc:ga942af7e6d95cc5d44778cb5ba2f56b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">SetBrightness function. With the setBrightness function, the user can adjust the brightness of the whole matrix. This works with a PWM signal which is sent using the the matrix::HT_1632_PWM_CONTROL command.  <a href="#ga942af7e6d95cc5d44778cb5ba2f56b36">More...</a><br /></td></tr>
<tr class="separator:ga942af7e6d95cc5d44778cb5ba2f56b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaaa0ec3078d91783cb444a6d22e365d0f"><td class="memItemLeft" align="right" valign="top"><a id="gaaa0ec3078d91783cb444a6d22e365d0f"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_t__1632.html#gaaa0ec3078d91783cb444a6d22e365d0f">matrix::HT_1632::ledmatrix</a> [24] = {0}</td></tr>
<tr class="memdesc:gaaa0ec3078d91783cb444a6d22e365d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array is the memory-buffer to store data temporarily before it gets written. <br /></td></tr>
<tr class="separator:gaaa0ec3078d91783cb444a6d22e365d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9205293567235e397cd40d2e335827d1"><td class="memItemLeft" align="right" valign="top"><a id="ga9205293567235e397cd40d2e335827d1"></a>
<a class="el" href="classspi_1_1bus.html">spi::bus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix::HT_1632::spi_bus</b></td></tr>
<tr class="separator:ga9205293567235e397cd40d2e335827d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b2fbb13d6f148d786759e14f524dcf"><td class="memItemLeft" align="right" valign="top"><a id="gaa7b2fbb13d6f148d786759e14f524dcf"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>matrix::HT_1632::type</b></td></tr>
<tr class="separator:gaa7b2fbb13d6f148d786759e14f524dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga5d50c06d2d3886cdd866cb20891d05c0"><td class="memItemLeft" align="right" valign="top"><a id="ga5d50c06d2d3886cdd866cb20891d05c0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>matrix::HT_1632::matrixWindow</b></td></tr>
<tr class="separator:ga5d50c06d2d3886cdd866cb20891d05c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac1c948d2a7639d54c6cc2a0d6aee0d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c948d2a7639d54c6cc2a0d6aee0d2f">&#9670;&nbsp;</a></span>blink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::blink </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blink function. This function lets you blink the whole matrix for x amount of seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>Amount of seconds to let the matrix blink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51370333005f486fb0d2877fe459e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51370333005f486fb0d2877fe459e596">&#9670;&nbsp;</a></span>clearPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::clearPixel </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ClearPixel function. The reverse of the setPixel function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The pixel's x location, from 0 to 15. </td></tr>
    <tr><td class="paramname">y</td><td>The pixel's y locatino, from 0 to 23 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f2a79fd8a1be6e44b847d8548962400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2a79fd8a1be6e44b847d8548962400">&#9670;&nbsp;</a></span>HT_1632()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matrix::HT_1632::HT_1632 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspi_1_1bus.html">spi::bus</a>&#160;</td>
          <td class="paramname"><em>spi_bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor. This is the constructor of my library,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_bus</td><td>this is the <a class="el" href="classspi_1_1bus.html">spi::bus</a> in which the pins are stored. </td></tr>
    <tr><td class="paramname">type</td><td>This is the MOS-FET type of the matrix. There are four types: -HT1632_COMMON_8NMOS -HT1632_COMMON_16NMOS -HT1632_COMMON_8PMOS -HT1632_COMMON_16PMOS They represent the physical presence of the amount of PMOS or NMOS transistors. I added this functionality because I was not sure if all HT1632 matrices have the same transistors in them. For the one I used HT1632_COMMON_16NMOS seemed to work. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e49c60cb79e44ba9f67d33c1986b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e49c60cb79e44ba9f67d33c1986b5e6">&#9670;&nbsp;</a></span>sendCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::sendCommand </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cendCommand function. This function is quite simple, and it is only used internally in the background. It does the following: </p>
<ul>
<li>Create a temporary spi transaction using the bus reference member variable.</li>
<li>put the matrix::commands::HT_1632_command code in first 3 bits.</li>
<li>OR (the bit operator) the actual command in the following, and remaining 9 bits.</li>
<li>transmit the 12 bit sequence to the HT1632 chip. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>this is the <a class="el" href="structmatrix_1_1commands.html">matrix::commands</a> command-code that needs to be sent. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga942af7e6d95cc5d44778cb5ba2f56b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga942af7e6d95cc5d44778cb5ba2f56b36">&#9670;&nbsp;</a></span>setBrightness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::setBrightness </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SetBrightness function. With the setBrightness function, the user can adjust the brightness of the whole matrix. This works with a PWM signal which is sent using the the matrix::HT_1632_PWM_CONTROL command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>This is the brightness value. The highest value is 0xF (15 in decimal). The lowest value is 0x0 (0 in decimal). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41e8cf0207f395b420124b73555abea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e8cf0207f395b420124b73555abea1">&#9670;&nbsp;</a></span>setPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::setPixel </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SetPixel function. The setPixel function is quite self-explanatory, it sets pixels at location x, y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The pixel's x location, from 0 to 15. </td></tr>
    <tr><td class="paramname">y</td><td>The pixel's y locatino, from 0 to 23. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3d327b762c8245ddc6f88ba26c46e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d327b762c8245ddc6f88ba26c46e82">&#9670;&nbsp;</a></span>writeRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::writeRam </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteRam function. The writeRam function writes data to the ram register directly. How it works: The complete transaction has a total of 14 bits, they are arranged as following: </p>
<ul>
<li>3 bits matrix::commands::HT_1632_WRITE command.</li>
<li>7 address bits. This is the register address on the HT1632 chip.</li>
<li>4 data bits. When the data is in the correct order, it is sent using a single spi transaction. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The 7 bit register address. </td></tr>
    <tr><td class="paramname">data</td><td>The 4 bit data, these bits are linked directly to the LEDs. If you enter 1000 (8 in decimal) as data, the first bit will be enabled. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga5ed82c4f2f682bcd439aa8a745f01f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed82c4f2f682bcd439aa8a745f01f0f">&#9670;&nbsp;</a></span>writeScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::HT_1632::writeScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WriteScreen function. WriteScreen is similar to hwlib::window::flush(), what it does is send the data stored in the memory buffer to the HT1632 chip. What's so special about this function is the following: It uses 'successive writing' which is a particular way of writing data over spi. Successive writing enables you to send data far more quickly than writing per register. This is because with successive writing only the first register address is sent, after that comes only data. I first used writeRam to write to each register individually but this was much slower because I had to sent each address too. With successive writing that's not required. </p>
<p>What makes this difficult? you may ask to yourself, The difficult part is that for this way of writing data, you must use different amounts of bitlengths after eachother, and all in but 1 spi transaction. So that's why I store the transaction in a temp variable, and destruct the transaction after I'm done. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
