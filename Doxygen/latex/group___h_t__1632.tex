\hypertarget{group___h_t__1632}{}\section{H\+T\+\_\+1632}
\label{group___h_t__1632}\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group___h_t__1632_ga4e49c60cb79e44ba9f67d33c1986b5e6}{matrix\+::\+H\+T\+\_\+1632\+::send\+Command} (uint16\+\_\+t cmd)
\begin{DoxyCompactList}\small\item\em cend\+Command function. This function is quite simple, and it is only used internally in the background. It does the following\+: \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_gac3d327b762c8245ddc6f88ba26c46e82}{matrix\+::\+H\+T\+\_\+1632\+::write\+Ram} (uint8\+\_\+t addr, uint8\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Write\+Ram function. The write\+Ram function writes data to the ram register directly. How it works\+: The complete transaction has a total of 14 bits, they are arranged as following\+: \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___h_t__1632_ga7125530a962e17d9a533453e10d19e15}\label{group___h_t__1632_ga7125530a962e17d9a533453e10d19e15}} 
void \hyperlink{group___h_t__1632_ga7125530a962e17d9a533453e10d19e15}{matrix\+::\+H\+T\+\_\+1632\+::dump\+Mem} ()
\begin{DoxyCompactList}\small\item\em Dump\+Mem function. This function loops over the internal memory buffer and clears it. If the \textquotesingle{}debug\textquotesingle{} define is set to true in the header file, the function shows the previous bitvalues stored in the buffer before clearing it. If debug is left as is, no output will be generated and the memory will be cleared without confirmation. \end{DoxyCompactList}\item 
\hyperlink{group___h_t__1632_ga6f2a79fd8a1be6e44b847d8548962400}{matrix\+::\+H\+T\+\_\+1632\+::\+H\+T\+\_\+1632} (\hyperlink{classspi_1_1bus}{spi\+::bus} spi\+\_\+bus, uint16\+\_\+t type)
\begin{DoxyCompactList}\small\item\em The constructor. This is the constructor of my library,. \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_ga41e8cf0207f395b420124b73555abea1}{matrix\+::\+H\+T\+\_\+1632\+::set\+Pixel} (uint16\+\_\+t x, uint16\+\_\+t y)
\begin{DoxyCompactList}\small\item\em Set\+Pixel function. The set\+Pixel function is quite self-\/explanatory, it sets pixels at location x, y. \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_ga51370333005f486fb0d2877fe459e596}{matrix\+::\+H\+T\+\_\+1632\+::clear\+Pixel} (uint16\+\_\+t x, uint16\+\_\+t y)
\begin{DoxyCompactList}\small\item\em Clear\+Pixel function. The reverse of the set\+Pixel function. \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_gac1c948d2a7639d54c6cc2a0d6aee0d2f}{matrix\+::\+H\+T\+\_\+1632\+::blink} (uint16\+\_\+t seconds)
\begin{DoxyCompactList}\small\item\em Blink function. This function lets you blink the whole matrix for x amount of seconds. \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_ga5ed82c4f2f682bcd439aa8a745f01f0f}{matrix\+::\+H\+T\+\_\+1632\+::write\+Screen} ()
\begin{DoxyCompactList}\small\item\em Write\+Screen function. Write\+Screen is similar to hwlib\+::window\+::flush(), what it does is send the data stored in the memory buffer to the H\+T1632 chip. What\textquotesingle{}s so special about this function is the following\+: It uses \textquotesingle{}successive writing\textquotesingle{} which is a particular way of writing data over spi. Successive writing enables you to send data far more quickly than writing per register. This is because with successive writing only the first register address is sent, after that comes only data. I first used write\+Ram to write to each register individually but this was much slower because I had to sent each address too. With successive writing that\textquotesingle{}s not required. \end{DoxyCompactList}\item 
void \hyperlink{group___h_t__1632_ga942af7e6d95cc5d44778cb5ba2f56b36}{matrix\+::\+H\+T\+\_\+1632\+::set\+Brightness} (uint8\+\_\+t b)
\begin{DoxyCompactList}\small\item\em Set\+Brightness function. With the set\+Brightness function, the user can adjust the brightness of the whole matrix. This works with a P\+WM signal which is sent using the the matrix\+::\+H\+T\+\_\+1632\+\_\+\+P\+W\+M\+\_\+\+C\+O\+N\+T\+R\+OL command. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___h_t__1632_gaaa0ec3078d91783cb444a6d22e365d0f}\label{group___h_t__1632_gaaa0ec3078d91783cb444a6d22e365d0f}} 
uint16\+\_\+t \hyperlink{group___h_t__1632_gaaa0ec3078d91783cb444a6d22e365d0f}{matrix\+::\+H\+T\+\_\+1632\+::ledmatrix} \mbox{[}24\mbox{]} = \{0\}
\begin{DoxyCompactList}\small\item\em This array is the memory-\/buffer to store data temporarily before it gets written. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___h_t__1632_ga9205293567235e397cd40d2e335827d1}\label{group___h_t__1632_ga9205293567235e397cd40d2e335827d1}} 
\hyperlink{classspi_1_1bus}{spi\+::bus} {\bfseries matrix\+::\+H\+T\+\_\+1632\+::spi\+\_\+bus}
\item 
\mbox{\Hypertarget{group___h_t__1632_gaa7b2fbb13d6f148d786759e14f524dcf}\label{group___h_t__1632_gaa7b2fbb13d6f148d786759e14f524dcf}} 
uint16\+\_\+t {\bfseries matrix\+::\+H\+T\+\_\+1632\+::type}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___h_t__1632_ga5d50c06d2d3886cdd866cb20891d05c0}\label{group___h_t__1632_ga5d50c06d2d3886cdd866cb20891d05c0}} 
class {\bfseries matrix\+::\+H\+T\+\_\+1632\+::matrix\+Window}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\mbox{\Hypertarget{group___h_t__1632_gac1c948d2a7639d54c6cc2a0d6aee0d2f}\label{group___h_t__1632_gac1c948d2a7639d54c6cc2a0d6aee0d2f}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!blink@{blink}}
\index{blink@{blink}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{blink()}{blink()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::blink (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{seconds }\end{DoxyParamCaption})}



Blink function. This function lets you blink the whole matrix for x amount of seconds. 


\begin{DoxyParams}{Parameters}
{\em seconds} & Amount of seconds to let the matrix blink. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group___h_t__1632_ga51370333005f486fb0d2877fe459e596}\label{group___h_t__1632_ga51370333005f486fb0d2877fe459e596}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!clear\+Pixel@{clear\+Pixel}}
\index{clear\+Pixel@{clear\+Pixel}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{clear\+Pixel()}{clearPixel()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::clear\+Pixel (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{x,  }\item[{uint16\+\_\+t}]{y }\end{DoxyParamCaption})}



Clear\+Pixel function. The reverse of the set\+Pixel function. 


\begin{DoxyParams}{Parameters}
{\em x} & The pixel\textquotesingle{}s x location, from 0 to 15. \\
\hline
{\em y} & The pixel\textquotesingle{}s y locatino, from 0 to 23 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group___h_t__1632_ga6f2a79fd8a1be6e44b847d8548962400}\label{group___h_t__1632_ga6f2a79fd8a1be6e44b847d8548962400}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{H\+T\+\_\+1632()}{HT\_1632()}}
{\footnotesize\ttfamily matrix\+::\+H\+T\+\_\+1632\+::\+H\+T\+\_\+1632 (\begin{DoxyParamCaption}\item[{\hyperlink{classspi_1_1bus}{spi\+::bus}}]{spi\+\_\+bus,  }\item[{uint16\+\_\+t}]{type }\end{DoxyParamCaption})}



The constructor. This is the constructor of my library,. 


\begin{DoxyParams}{Parameters}
{\em spi\+\_\+bus} & this is the \hyperlink{classspi_1_1bus}{spi\+::bus} in which the pins are stored. \\
\hline
{\em type} & This is the M\+O\+S-\/\+F\+ET type of the matrix. There are four types\+: -\/\+H\+T1632\+\_\+\+C\+O\+M\+M\+O\+N\+\_\+8\+N\+M\+OS -\/\+H\+T1632\+\_\+\+C\+O\+M\+M\+O\+N\+\_\+16\+N\+M\+OS -\/\+H\+T1632\+\_\+\+C\+O\+M\+M\+O\+N\+\_\+8\+P\+M\+OS -\/\+H\+T1632\+\_\+\+C\+O\+M\+M\+O\+N\+\_\+16\+P\+M\+OS They represent the physical presence of the amount of P\+M\+OS or N\+M\+OS transistors. I added this functionality because I was not sure if all H\+T1632 matrices have the same transistors in them. For the one I used H\+T1632\+\_\+\+C\+O\+M\+M\+O\+N\+\_\+16\+N\+M\+OS seemed to work. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group___h_t__1632_ga4e49c60cb79e44ba9f67d33c1986b5e6}\label{group___h_t__1632_ga4e49c60cb79e44ba9f67d33c1986b5e6}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!send\+Command@{send\+Command}}
\index{send\+Command@{send\+Command}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{send\+Command()}{sendCommand()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::send\+Command (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{cmd }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



cend\+Command function. This function is quite simple, and it is only used internally in the background. It does the following\+: 


\begin{DoxyItemize}
\item Create a temporary spi transaction using the bus reference member variable.
\item put the matrix\+::commands\+::\+H\+T\+\_\+1632\+\_\+command code in first 3 bits.
\item OR (the bit operator) the actual command in the following, and remaining 9 bits.
\item transmit the 12 bit sequence to the H\+T1632 chip. 
\begin{DoxyParams}{Parameters}
{\em cmd} & this is the \hyperlink{structmatrix_1_1commands}{matrix\+::commands} command-\/code that needs to be sent. \\
\hline
\end{DoxyParams}

\end{DoxyItemize}\mbox{\Hypertarget{group___h_t__1632_ga942af7e6d95cc5d44778cb5ba2f56b36}\label{group___h_t__1632_ga942af7e6d95cc5d44778cb5ba2f56b36}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!set\+Brightness@{set\+Brightness}}
\index{set\+Brightness@{set\+Brightness}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{set\+Brightness()}{setBrightness()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::set\+Brightness (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{b }\end{DoxyParamCaption})}



Set\+Brightness function. With the set\+Brightness function, the user can adjust the brightness of the whole matrix. This works with a P\+WM signal which is sent using the the matrix\+::\+H\+T\+\_\+1632\+\_\+\+P\+W\+M\+\_\+\+C\+O\+N\+T\+R\+OL command. 


\begin{DoxyParams}{Parameters}
{\em b} & This is the brightness value. The highest value is 0xF (15 in decimal). The lowest value is 0x0 (0 in decimal). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group___h_t__1632_ga41e8cf0207f395b420124b73555abea1}\label{group___h_t__1632_ga41e8cf0207f395b420124b73555abea1}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!set\+Pixel@{set\+Pixel}}
\index{set\+Pixel@{set\+Pixel}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{set\+Pixel()}{setPixel()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::set\+Pixel (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{x,  }\item[{uint16\+\_\+t}]{y }\end{DoxyParamCaption})}



Set\+Pixel function. The set\+Pixel function is quite self-\/explanatory, it sets pixels at location x, y. 


\begin{DoxyParams}{Parameters}
{\em x} & The pixel\textquotesingle{}s x location, from 0 to 15. \\
\hline
{\em y} & The pixel\textquotesingle{}s y locatino, from 0 to 23. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group___h_t__1632_gac3d327b762c8245ddc6f88ba26c46e82}\label{group___h_t__1632_gac3d327b762c8245ddc6f88ba26c46e82}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!write\+Ram@{write\+Ram}}
\index{write\+Ram@{write\+Ram}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{write\+Ram()}{writeRam()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::write\+Ram (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{addr,  }\item[{uint8\+\_\+t}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Write\+Ram function. The write\+Ram function writes data to the ram register directly. How it works\+: The complete transaction has a total of 14 bits, they are arranged as following\+: 


\begin{DoxyItemize}
\item 3 bits matrix\+::commands\+::\+H\+T\+\_\+1632\+\_\+\+W\+R\+I\+TE command.
\item 7 address bits. This is the register address on the H\+T1632 chip.
\item 4 data bits. When the data is in the correct order, it is sent using a single spi transaction. 
\begin{DoxyParams}{Parameters}
{\em addr} & The 7 bit register address. \\
\hline
{\em data} & The 4 bit data, these bits are linked directly to the L\+E\+Ds. If you enter 1000 (8 in decimal) as data, the first bit will be enabled. \\
\hline
\end{DoxyParams}

\end{DoxyItemize}\mbox{\Hypertarget{group___h_t__1632_ga5ed82c4f2f682bcd439aa8a745f01f0f}\label{group___h_t__1632_ga5ed82c4f2f682bcd439aa8a745f01f0f}} 
\index{H\+T\+\_\+1632@{H\+T\+\_\+1632}!write\+Screen@{write\+Screen}}
\index{write\+Screen@{write\+Screen}!H\+T\+\_\+1632@{H\+T\+\_\+1632}}
\subsubsection{\texorpdfstring{write\+Screen()}{writeScreen()}}
{\footnotesize\ttfamily void matrix\+::\+H\+T\+\_\+1632\+::write\+Screen (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Write\+Screen function. Write\+Screen is similar to hwlib\+::window\+::flush(), what it does is send the data stored in the memory buffer to the H\+T1632 chip. What\textquotesingle{}s so special about this function is the following\+: It uses \textquotesingle{}successive writing\textquotesingle{} which is a particular way of writing data over spi. Successive writing enables you to send data far more quickly than writing per register. This is because with successive writing only the first register address is sent, after that comes only data. I first used write\+Ram to write to each register individually but this was much slower because I had to sent each address too. With successive writing that\textquotesingle{}s not required. 

What makes this difficult? you may ask to yourself, The difficult part is that for this way of writing data, you must use different amounts of bitlengths after eachother, and all in but 1 spi transaction. So that\textquotesingle{}s why I store the transaction in a temp variable, and destruct the transaction after I\textquotesingle{}m done. 